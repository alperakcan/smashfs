Index: lib/Kconfig
===================================================================
Index: lib/Makefile
===================================================================
Index: fs/Kconfig
===================================================================
--- fs/Kconfig	(revision 28980)
+++ fs/Kconfig	(working copy)
@@ -182,6 +182,7 @@
 source "fs/logfs/Kconfig"
 source "fs/cramfs/Kconfig"
 source "fs/squashfs/Kconfig"
+source "fs/smashfs/Kconfig"
 source "fs/freevxfs/Kconfig"
 source "fs/minix/Kconfig"
 source "fs/omfs/Kconfig"
Index: fs/Makefile
===================================================================
--- fs/Makefile	(revision 28980)
+++ fs/Makefile	(working copy)
@@ -71,6 +71,7 @@
 obj-$(CONFIG_JBD2)		+= jbd2/
 obj-$(CONFIG_CRAMFS)		+= cramfs/
 obj-$(CONFIG_SQUASHFS)		+= squashfs/
+obj-$(CONFIG_SMASHFS)		+= smashfs/
 obj-y				+= ramfs/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
Index: fs/smashfs/compressor-lzma.c
===================================================================
--- fs/smashfs/compressor-lzma.c	(revision 0)
+++ fs/smashfs/compressor-lzma.c	(revision 0)
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+
+int lzma_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	(void) src;
+	(void) ssize;
+	(void) dst;
+	(void) dsize;
+	return -1;
+}
+
+int lzma_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	(void) src;
+	(void) ssize;
+	(void) dst;
+	(void) dsize;
+	return -1;
+}
Index: fs/smashfs/compressor-lzo.c
===================================================================
--- fs/smashfs/compressor-lzo.c	(revision 0)
+++ fs/smashfs/compressor-lzo.c	(revision 0)
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/lzo.h>
+
+int lzo_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	(void) src;
+	(void) ssize;
+	(void) dst;
+	(void) dsize;
+	return -1;
+}
+
+int lzo_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	int rc;
+	size_t out;
+	out = dsize;
+	rc = lzo1x_decompress_safe(src, ssize, dst, &out);
+	if (rc != LZO_E_OK) {
+		return -1;
+	}
+	return out;
+}
Index: fs/smashfs/compressor-none.h
===================================================================
--- fs/smashfs/compressor-none.h	(revision 0)
+++ fs/smashfs/compressor-none.h	(revision 0)
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+int none_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
+int none_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
Index: fs/smashfs/super.c
===================================================================
--- fs/smashfs/super.c	(revision 0)
+++ fs/smashfs/super.c	(revision 0)
@@ -0,0 +1,1305 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/buffer_head.h>
+#include <linux/statfs.h>
+#include <linux/namei.h>
+#include <linux/version.h>
+
+#include "smashfs.h"
+#include "bitbuffer.h"
+#include "compressor.h"
+#include "super.h"
+
+#define errorf(a...) { \
+	printk(KERN_ERR "smashfs: " a); \
+}
+
+#if 0
+#define debugf(a...) { \
+	printk(KERN_INFO "smashfs: " a); \
+}
+#else
+#define debugf(a...)
+#endif
+
+#define enterf() { \
+	debugf("enter (%s %s:%d)\n", __FUNCTION__, __FILE__, __LINE__); \
+}
+
+#define leavef() { \
+	debugf("leave (%s %s:%d)\n", __FUNCTION__, __FILE__, __LINE__); \
+}
+
+struct block {
+	long long offset;
+	long long size;
+	long long compressed_size;
+};
+
+struct node {
+	long long number;
+	long long type;
+	long long owner_mode;
+	long long group_mode;
+	long long other_mode;
+	long long uid;
+	long long gid;
+	long long ctime;
+	long long mtime;
+	long long size;
+	long long block;
+	long long index;
+};
+
+struct node_info {
+	struct node node;
+	struct inode inode;
+};
+
+static const struct super_operations smashfs_super_ops;
+static const struct file_operations smashfs_directory_operations;
+static const struct inode_operations smashfs_dir_inode_operations;
+static const struct address_space_operations smashfs_aops;
+
+static struct kmem_cache *smashfs_inode_cachep			= NULL;
+
+static DEFINE_MUTEX(read_mutex);
+
+struct block_cache {
+	struct block block;
+	void *buffer;
+};
+
+static int block_caches_max					= 1;
+module_param(block_caches_max, int, S_IRUGO);
+MODULE_PARM_DESC(block_caches_max, "number of allowed block caches (default: 1)");
+
+static DEFINE_MUTEX(block_cache_mutex);
+
+static long long nblock_caches					= 0;
+static struct block_cache *block_caches				= NULL;
+
+static inline struct node_info * smashfs_i (struct inode *inode)
+{
+	return container_of(inode, struct node_info, inode);
+}
+
+static inline int block_fill (struct super_block *sb, long long number, struct block *block)
+{
+	int rc;
+	struct bitbuffer bb;
+	struct smashfs_super_info *sbi;
+
+	enterf();
+
+	debugf("looking for block number: %lld\n", number);
+
+	sbi = sb->s_fs_info;
+	debugf("blocks_table: %p, blocks_size: %d\n", sbi->blocks_table, sbi->super->blocks_size);
+
+	rc = bitbuffer_init_from_buffer(&bb, sbi->blocks_table, sbi->super->blocks_size);
+	if (rc != 0) {
+		errorf("bitbuffer init from buffer failed\n");
+		leavef();
+		return -1;
+	}
+
+	bitbuffer_setpos(&bb, number * sbi->max_block_size);
+	block->offset           = bitbuffer_getbits(&bb, sbi->super->bits.block.offset);
+	block->compressed_size  = bitbuffer_getbits(&bb, sbi->super->bits.block.compressed_size) + sbi->super->min.block.compressed_size;
+	block->size             = (number + 1 < sbi->super->blocks) ? sbi->super->block_size : bitbuffer_getbits(&bb, sbi->super->bits.block.size);
+	bitbuffer_uninit(&bb);
+
+	debugf("block:\n");
+	debugf("  number: %lld\n", number);
+	debugf("  offset: %lld\n", block->offset);
+	debugf("  csize : %lld\n", block->compressed_size);
+	debugf("  size  : %lld\n", block->size);
+
+	leavef();
+	return 0;
+}
+
+static inline int node_fill (struct super_block *sb, long long number, struct node *node)
+{
+	int rc;
+	struct bitbuffer bb;
+	struct smashfs_super_info *sbi;
+
+	enterf();
+
+	debugf("looking for node number: %lld\n", number);
+
+	sbi = sb->s_fs_info;
+	debugf("inodes_table: %p, inodes_size: %d", sbi->inodes_table, sbi->super->inodes_size);
+
+	rc = bitbuffer_init_from_buffer(&bb, sbi->inodes_table, sbi->super->inodes_size);
+	if (rc != 0) {
+		errorf("bitbuffer init for inodes tabled failed\n");
+		leavef();
+		return -1;
+	}
+
+	bitbuffer_setpos(&bb, number * sbi->max_inode_size);
+	node->number     = number;
+	node->type       = bitbuffer_getbits(&bb, sbi->super->bits.inode.type);
+	node->owner_mode = bitbuffer_getbits(&bb, sbi->super->bits.inode.owner_mode);
+	node->group_mode = bitbuffer_getbits(&bb, sbi->super->bits.inode.group_mode);
+	node->other_mode = bitbuffer_getbits(&bb, sbi->super->bits.inode.other_mode);
+	node->uid        = bitbuffer_getbits(&bb, sbi->super->bits.inode.uid);
+	node->gid        = bitbuffer_getbits(&bb, sbi->super->bits.inode.gid);
+	node->ctime      = bitbuffer_getbits(&bb, sbi->super->bits.inode.ctime);
+	node->mtime      = bitbuffer_getbits(&bb, sbi->super->bits.inode.mtime);
+	node->size       = bitbuffer_getbits(&bb, sbi->super->bits.inode.size);
+	node->block      = bitbuffer_getbits(&bb, sbi->super->bits.inode.block);
+	node->index      = bitbuffer_getbits(&bb, sbi->super->bits.inode.index);
+	bitbuffer_uninit(&bb);
+
+	if (sbi->super->bits.inode.group_mode == 0) {
+		node->group_mode = node->owner_mode;
+	}
+	if (sbi->super->bits.inode.other_mode == 0) {
+		node->other_mode = node->owner_mode;
+	}
+	if (sbi->super->bits.inode.uid == 0) {
+		node->uid = 0;
+	}
+	if (sbi->super->bits.inode.gid == 0) {
+		node->gid = 0;
+	}
+	if (sbi->super->bits.inode.ctime == 0) {
+		node->ctime  = sbi->super->ctime;
+	}
+	if (sbi->super->bits.inode.mtime == 0) {
+		node->mtime = node->ctime;
+	}
+	node->ctime += sbi->super->min.inode.ctime;
+	node->mtime += sbi->super->min.inode.mtime;
+
+	debugf("node\n");
+	debugf("  number: %lld\n", node->number);
+	debugf("  type  : %lld\n", node->type);
+	debugf("  size  : %lld\n", node->size);
+
+	leavef();
+	return 0;
+}
+
+static inline struct inode * smashfs_get_inode (struct super_block *sb, long long number)
+{
+	int rc;
+	mode_t mode;
+	struct node node;
+	struct inode *inode;
+	struct node_info *node_info;
+	struct smashfs_super_info *sbi;
+
+	enterf();
+
+	inode = iget_locked(sb, number + 1);
+	if (inode == NULL) {
+		errorf("iget_locked failed\n");
+		leavef();
+		return ERR_PTR(-ENOMEM);
+	}
+
+	if ((inode->i_state & I_NEW) == 0) {
+		debugf("inode is not new for %lld\n", number);
+		leavef();
+		return inode;
+	}
+
+	rc = node_fill(sb, number, &node);
+	if (rc != 0) {
+		errorf("node fill failed\n");
+		iget_failed(inode);
+		leavef();
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (node.type == smashfs_inode_type_directory) {
+		mode                = S_IFDIR;
+		inode->i_op         = &smashfs_dir_inode_operations;
+		inode->i_fop        = &smashfs_directory_operations;
+	} else if (node.type == smashfs_inode_type_regular_file) {
+		mode                = S_IFREG;
+		inode->i_fop        = &generic_ro_fops;
+		inode->i_data.a_ops = &smashfs_aops;
+	} else if (node.type == smashfs_inode_type_symbolic_link) {
+		mode                = S_IFLNK;
+		inode->i_op         = &page_symlink_inode_operations;
+		inode->i_data.a_ops = &smashfs_aops;
+	} else {
+		errorf("unknown node type: %lld\n", node.type);
+		iget_failed(inode);
+		leavef();
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (node.owner_mode & smashfs_inode_mode_read) {
+		mode |= S_IRUSR;
+	}
+	if (node.owner_mode & smashfs_inode_mode_write) {
+		mode |= S_IWUSR;
+	}
+	if (node.owner_mode & smashfs_inode_mode_execute) {
+		mode |= S_IXUSR;
+	}
+	if (node.group_mode & smashfs_inode_mode_read) {
+		mode |= S_IRGRP;
+	}
+	if (node.group_mode & smashfs_inode_mode_write) {
+		mode |= S_IWGRP;
+	}
+	if (node.group_mode & smashfs_inode_mode_execute) {
+		mode |= S_IXGRP;
+	}
+	if (node.other_mode & smashfs_inode_mode_read) {
+		mode |= S_IROTH;
+	}
+	if (node.other_mode & smashfs_inode_mode_write) {
+		mode |= S_IWOTH;
+	}
+	if (node.other_mode & smashfs_inode_mode_execute) {
+		mode |= S_IXOTH;
+	}
+
+	sbi = sb->s_fs_info;
+
+	inode->i_mode   = mode;
+	inode->i_uid    = node.uid;
+	inode->i_gid    = node.gid;
+	inode->i_size   = node.size;
+	inode->i_blocks = ((node.size + sbi->devblksize - 1) >> sbi->devblksize_log2) + 1;
+	inode->i_ctime.tv_sec = node.ctime;
+	inode->i_mtime.tv_sec = node.mtime;
+	inode->i_atime.tv_sec = node.mtime;
+
+	node_info = smashfs_i(inode);
+	memcpy(&node_info->node, &node, sizeof(struct node));
+
+	unlock_new_inode(inode);
+
+	leavef();
+	return inode;
+}
+
+static inline int smashfs_read (struct super_block *sb, void *buffer, int offset, int length)
+{
+	int i;
+	int b;
+	int in;
+	int page;
+	int avail;
+	int bytes;
+	int pages;
+	int index;
+	int block;
+	int blocks;
+	int pageoff;
+
+	void **data;
+	struct buffer_head **bh;
+	struct smashfs_super_info *sbi;
+
+	enterf();
+
+	mutex_lock(&read_mutex);
+
+	pages = (length + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+	data = kcalloc(pages, sizeof(void *), GFP_KERNEL);
+	if (data == NULL) {
+		errorf("kcalloc failed\n");
+		mutex_unlock(&read_mutex);
+		leavef();
+		return -ENOMEM;
+	}
+	for (i = 0; i < pages; i++, buffer += PAGE_CACHE_SIZE) {
+		data[i] = buffer;
+	}
+
+	sbi = sb->s_fs_info;
+	index = offset & ((1 << sbi->devblksize_log2) - 1);
+	block = offset >> sbi->devblksize_log2;
+	blocks = ((length + sbi->devblksize - 1) >> sbi->devblksize_log2) + 1;
+
+	debugf("offset: %d, length: %d, pages: %d, block: %d, index: %d, blocks: %d\n", offset, length, pages, block, index, blocks);
+	bh = kcalloc(blocks, sizeof(struct buffer_head *), GFP_KERNEL);
+	if (bh == NULL) {
+		errorf("kcalloc failed for buffer heads\n");
+		kfree(data);
+		mutex_unlock(&read_mutex);
+		leavef();
+		return -ENOMEM;
+	}
+
+	b = 0;
+	bytes = -index;
+	debugf("bytes: %d, length: %d, bytes < length: %d\n", bytes, length, bytes < length);
+	while (bytes < length) {
+		bh[b] = sb_getblk(sb, block);
+		if (bh[b] == NULL) {
+			errorf("sb_getblk failed\n");
+			for (i = 0; i < b; i++) {
+				put_bh(bh[i]);
+			}
+			kfree(bh);
+			kfree(data);
+			mutex_unlock(&read_mutex);
+			leavef();
+			return -EIO;
+		}
+		b += 1;
+		block += 1;
+		bytes += sbi->devblksize;
+	}
+
+	ll_rw_block(READ, b, bh);
+	for (i = 0; i < b; i++) {
+		wait_on_buffer(bh[i]);
+		if (!buffer_uptodate(bh[i])) {
+			errorf("buffer_uptodate failed\n");
+			for (i = 0; i < b; i++) {
+				put_bh(bh[i]);
+			}
+			kfree(bh);
+			kfree(data);
+			mutex_unlock(&read_mutex);
+			leavef();
+			return -EIO;
+		}
+	}
+
+	page = 0;
+	pageoff = 0;
+	for (bytes = length, i = 0; i < b; i++) {
+		in = min(bytes, sbi->devblksize - index);
+		bytes -= in;
+		while (in) {
+			if (pageoff == PAGE_CACHE_SIZE) {
+				page++;
+				pageoff = 0;
+			}
+			avail = min_t(int, in, PAGE_CACHE_SIZE - pageoff);
+			memcpy(data[page] + pageoff, bh[i]->b_data + index, avail);
+			in -= avail;
+			pageoff += avail;
+			index += avail;
+		}
+		index = 0;
+		put_bh(bh[i]);
+	}
+
+	for (; i < b; i++) {
+		put_bh(bh[i]);
+	}
+
+	kfree(bh);
+	kfree(data);
+	mutex_unlock(&read_mutex);
+	leavef();
+	return length;
+}
+
+static inline int node_read (struct super_block *sb, struct node *node, int (*function) (void *context, void *buffer, long long size), void *context, long long offset, long long size)
+{
+	int rc;
+	long long c;
+	long long s;
+	long long i;
+	long long b;
+	long long n;
+	long long o;
+	long long l;
+	void *ubuffer;
+	void *cbuffer;
+	struct block block;
+	struct block_cache *blockc;
+	struct smashfs_super_info *sbi;
+
+	enterf();
+	debugf("offset: %lld, size: %lld\n", offset, size);
+
+	sbi = sb->s_fs_info;
+
+	ubuffer = kmalloc(sbi->super->block_size, GFP_KERNEL);
+	if (ubuffer == NULL) {
+		errorf("malloc failed\n");
+		leavef();
+		return -1;
+	}
+	cbuffer = kmalloc(sbi->super->block_size, GFP_KERNEL);
+	if (cbuffer == NULL) {
+		errorf("malloc failed\n");
+		kfree(ubuffer);
+		leavef();
+		return -1;
+	}
+
+	o = offset + node->index + (node->block * sbi->super->block_size);
+	i = o & ((1 << sbi->super->block_log2) - 1);
+	b = o >> sbi->super->block_log2;
+	n = ((size + sbi->super->block_size - 1) >> sbi->super->block_log2) + 1;
+	debugf("offset: %lld, index: %lld, block: %lld, blocks: %lld\n", offset, i, b, n);
+
+	s = 0;
+	while (s < size) {
+		rc = block_fill(sb, b, &block);
+		if (rc != 0) {
+			errorf("block fill failed\n");
+			goto bail;
+		}
+		if (block.size > sbi->super->block_size) {
+			errorf("logic error\n");
+			goto bail;
+		}
+
+		mutex_lock(&block_cache_mutex);
+		for (c = 0; c < nblock_caches; c++) {
+			blockc = &block_caches[c];
+			if (memcmp(&blockc->block, &block, sizeof(struct block)) == 0) {
+				break;
+			}
+		}
+		if (c < nblock_caches) {
+			memcpy(ubuffer, blockc->buffer, block.size);
+			mutex_unlock(&block_cache_mutex);
+
+			l = min_t(long long, size - s, block.size - i);
+			rc = function(context, ubuffer + i, l);
+			if (rc != l) {
+				errorf("function failed\n");
+				goto bail;
+			}
+			s += l;
+			b += 1;
+			i = 0;
+		} else {
+			mutex_unlock(&block_cache_mutex);
+			rc = smashfs_read(sb, cbuffer, sbi->super->entries_offset + block.offset, block.compressed_size);
+			if (rc != block.compressed_size) {
+				errorf("read block failed");
+				goto bail;
+			}
+			rc = compressor_uncompress(sbi->compressor, cbuffer, block.compressed_size, ubuffer, block.size);
+			if (rc != block.size) {
+				errorf("uncompress failed");
+				goto bail;
+			}
+
+			l = min_t(long long, size - s, block.size - i);
+			rc = function(context, ubuffer + i, l);
+			if (rc != l) {
+				errorf("function failed\n");
+				goto bail;
+			}
+			s += l;
+			b += 1;
+			i = 0;
+
+			if (block_caches_max > 0) {
+				mutex_lock(&block_cache_mutex);
+				if (nblock_caches == block_caches_max) {
+					kfree(block_caches[block_caches_max - 1].buffer);
+				}
+				memmove(&block_caches[1], &block_caches[0], sizeof(struct block_cache) * (block_caches_max - 1));
+				memcpy(&block_caches[0].block, &block, sizeof(struct block));
+				block_caches[0].buffer = ubuffer;
+				nblock_caches = min_t(long long, nblock_caches + 1, block_caches_max);
+				mutex_unlock(&block_cache_mutex);
+
+				ubuffer = kmalloc(sbi->super->block_size, GFP_KERNEL);
+				if (ubuffer == NULL) {
+					errorf("malloc failed\n");
+					kfree(cbuffer);
+					leavef();
+					return -1;
+				}
+			}
+		}
+	}
+
+	kfree(cbuffer);
+	kfree(ubuffer);
+	leavef();
+	return 0;
+bail:
+	kfree(cbuffer);
+	kfree(ubuffer);
+	leavef();
+	return -1;
+}
+
+static int node_read_directory (void *context, void *buffer, long long size)
+{
+	unsigned char **b;
+
+	enterf();
+
+	b = context;
+	memcpy(*b, buffer, size);
+	*b += size;
+
+	leavef();
+	return size;
+}
+
+static int node_read_symbolic_link (void *context, void *buffer, long long size)
+{
+	unsigned char **b;
+
+	enterf();
+
+	b = context;
+	memcpy(*b, buffer, size);
+	*b += size;
+
+	leavef();
+	return size;
+}
+
+static int node_read_regular_file (void *context, void *buffer, long long size)
+{
+	unsigned char **b;
+
+	enterf();
+
+	b = context;
+	memcpy(*b, buffer, size);
+	*b += size;
+
+	leavef();
+	return size;
+}
+
+static int smashfs_readdir (struct file *filp, void *dirent, filldir_t filldir)
+{
+	int rc;
+
+	struct node *node;
+
+	char *buffer;
+	char *nbuffer;
+	struct bitbuffer bb;
+
+	struct inode *inode;
+	struct super_block *sb;
+	struct smashfs_super_info *sbi;
+
+	long long e;
+	long long s;
+	long long directory_parent;
+	long long directory_nentries;
+	long long directory_entry_number;
+	long long directory_entry_length;
+	long long directory_entry_type;
+
+	enterf();
+
+	debugf("filp->f_pos: %lld\n", filp->f_pos);
+
+	nbuffer = NULL;
+	inode = filp->f_path.dentry->d_inode;
+	sb = inode->i_sb;
+	sbi = sb->s_fs_info;
+
+	node = &(smashfs_i(inode)->node);
+
+	if (filp->f_pos >= 3 + node->size) {
+		debugf("finished reading (%lld, %lld)\n", filp->f_pos, node->size);
+		leavef();
+		return 0;
+	}
+
+	nbuffer = kmalloc(node->size, GFP_KERNEL);
+	if (nbuffer == NULL) {
+		errorf("kmalloc failed\n");
+		leavef();
+		return -ENOMEM;
+	}
+
+	buffer = nbuffer;
+	rc = node_read(sb, node, node_read_directory, &buffer, 0, node->size);
+	if (rc != 0) {
+		errorf("node read failed\n");
+		kfree(nbuffer);
+		leavef();
+		return -EIO;
+	}
+
+	buffer = nbuffer;
+	bitbuffer_init_from_buffer(&bb, buffer, node->size);
+	directory_parent   = bitbuffer_getbits(&bb, sbi->super->bits.inode.directory.parent);
+	directory_nentries = bitbuffer_getbits(&bb, sbi->super->bits.inode.directory.nentries);
+	bitbuffer_uninit(&bb);
+
+	while (filp->f_pos < 3) {
+		int i_ino;
+		char *name;
+		if (filp->f_pos == 0) {
+			name = ".";
+			s = 1;
+			i_ino = inode->i_ino;
+		} else {
+			name = "..";
+			s = 2;
+			i_ino = directory_parent + 1;
+		}
+		debugf("calling filldir(%p, %s, %lld, %lld, %d, %d)\n", dirent, name, s, filp->f_pos, i_ino, DT_DIR);
+		if (filldir(dirent, name, s, filp->f_pos, i_ino, DT_DIR) < 0) {
+			debugf("filldir failed\n");
+			kfree(nbuffer);
+			leavef();
+			return 0;
+		}
+		filp->f_pos += s;
+	}
+
+	debugf("number: %lld, parent: %lld, nentries: %lld\n", node->number, directory_parent, directory_nentries);
+	s  = 0;
+	s += sbi->super->bits.inode.directory.parent;
+	s += sbi->super->bits.inode.directory.nentries;
+	s  = (s + 7) / 8;
+	buffer += s;
+	if (filp->f_pos < 3 + s) {
+		filp->f_pos += s;
+	}
+
+	for (e = 0; e < directory_nentries; e++) {
+		s  = 0;
+		s += sbi->super->bits.inode.directory.entries.number;
+		s += sbi->super->bits.inode.directory.entries.length;
+		s += sbi->super->bits.inode.directory.entries.type;
+		s  = (s + 7) / 8;
+
+		bitbuffer_init_from_buffer(&bb, buffer, s);
+		directory_entry_number = bitbuffer_getbits(&bb, sbi->super->bits.inode.directory.entries.number);
+		directory_entry_length = bitbuffer_getbits(&bb, sbi->super->bits.inode.directory.entries.length);
+		directory_entry_type = bitbuffer_getbits(&bb, sbi->super->bits.inode.directory.entries.type);
+		bitbuffer_uninit(&bb);
+
+		buffer += s;
+
+		debugf("  - %lld, f_pos: %lld, %zd\n", directory_entry_number, filp->f_pos, ((buffer - s) - nbuffer) + 3);
+		if (filp->f_pos == ((buffer - s) - nbuffer) + 3) {
+			debugf("    calling filldir(%p, %lld, %lld, %lld, %s)\n",
+				dirent,
+				directory_entry_length,
+				filp->f_pos,
+				directory_entry_number + 1,
+				(directory_entry_type == smashfs_inode_type_regular_file) ? "DT_REG" :
+				(directory_entry_type == smashfs_inode_type_directory) ? "DT_DIR" :
+				(directory_entry_type == smashfs_inode_type_symbolic_link) ? "DT_LNK" :
+				(directory_entry_type == smashfs_inode_type_character_device) ? "DT_CHR" :
+				(directory_entry_type == smashfs_inode_type_block_device) ? "DT_BLK" :
+				(directory_entry_type == smashfs_inode_type_fifo) ? "DT_FIFO" :
+				(directory_entry_type == smashfs_inode_type_socket) ? "DT_SOCK" : "DT_UNKNOWN");
+			if (filldir(dirent,
+				    buffer,
+				    directory_entry_length,
+				    filp->f_pos,
+				    directory_entry_number + 1,
+				    (directory_entry_type == smashfs_inode_type_regular_file) ? DT_REG :
+				    (directory_entry_type == smashfs_inode_type_directory) ? DT_DIR :
+				    (directory_entry_type == smashfs_inode_type_symbolic_link) ? DT_LNK :
+				    (directory_entry_type == smashfs_inode_type_character_device) ? DT_CHR :
+				    (directory_entry_type == smashfs_inode_type_block_device) ? DT_BLK :
+				    (directory_entry_type == smashfs_inode_type_fifo) ? DT_FIFO :
+				    (directory_entry_type == smashfs_inode_type_socket) ? DT_SOCK : DT_UNKNOWN) < 0) {
+				debugf("filldir failed\n");
+				kfree(nbuffer);
+				leavef();
+				return 0;
+			}
+			filp->f_pos += s;
+			filp->f_pos += directory_entry_length;
+		}
+
+		buffer += directory_entry_length;
+	}
+
+	kfree(nbuffer);
+	leavef();
+	return 0;
+}
+
+static struct dentry * smashfs_lookup (struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+{
+	int rc;
+
+	struct node *node;
+
+	char *buffer;
+	char *nbuffer;
+	struct bitbuffer bb;
+
+	struct inode *inode;
+	struct super_block *sb;
+	struct smashfs_super_info *sbi;
+
+	long long e;
+	long long s;
+	long long directory_parent;
+	long long directory_nentries;
+	long long directory_entry_number;
+	long long directory_entry_length;
+
+	enterf();
+
+	inode = NULL;
+	nbuffer = NULL;
+	sb = dir->i_sb;
+	sbi = sb->s_fs_info;
+
+	node = &(smashfs_i(dir)->node);
+
+	nbuffer = kmalloc(node->size, GFP_KERNEL);
+	if (nbuffer == NULL) {
+		errorf("kmalloc failed\n");
+		leavef();
+		return ERR_PTR(-ENOMEM);
+	}
+
+	buffer = nbuffer;
+	rc = node_read(sb, node, node_read_directory, &buffer, 0, node->size);
+	if (rc != 0) {
+		errorf("node read failed\n");
+		kfree(nbuffer);
+		leavef();
+		return ERR_PTR(-EIO);
+	}
+
+	buffer = nbuffer;
+	bitbuffer_init_from_buffer(&bb, buffer, node->size);
+	directory_parent   = bitbuffer_getbits(&bb, sbi->super->bits.inode.directory.parent);
+	directory_nentries = bitbuffer_getbits(&bb, sbi->super->bits.inode.directory.nentries);
+	bitbuffer_uninit(&bb);
+
+	debugf("number: %lld, parent: %lld, nentries: %lld\n", node->number, directory_parent, directory_nentries);
+	s  = 0;
+	s += sbi->super->bits.inode.directory.parent;
+	s += sbi->super->bits.inode.directory.nentries;
+	s  = (s + 7) / 8;
+	buffer += s;
+
+	for (e = 0; e < directory_nentries; e++) {
+		s  = 0;
+		s += sbi->super->bits.inode.directory.entries.number;
+		s += sbi->super->bits.inode.directory.entries.length;
+		s += sbi->super->bits.inode.directory.entries.type;
+		s  = (s + 7) / 8;
+
+		bitbuffer_init_from_buffer(&bb, buffer, s);
+		directory_entry_number = bitbuffer_getbits(&bb, sbi->super->bits.inode.directory.entries.number);
+		directory_entry_length = bitbuffer_getbits(&bb, sbi->super->bits.inode.directory.entries.length);
+		/* directory_entry_type */ bitbuffer_skipbits(&bb, sbi->super->bits.inode.directory.entries.type);
+		bitbuffer_uninit(&bb);
+
+		buffer += s;
+
+		if (dentry->d_name.name[0] < buffer[0]) {
+			break;
+		}
+
+		if (directory_entry_length == dentry->d_name.len &&
+		    memcmp(buffer, dentry->d_name.name, dentry->d_name.len) == 0) {
+			debugf("  - %lld\n", directory_entry_number);
+			inode = smashfs_get_inode(sb, directory_entry_number);
+			if (inode == NULL) {
+				errorf("get inode failed\n");
+				leavef();
+				return ERR_PTR(-EIO);
+			} else {
+				leavef();
+				return d_splice_alias(inode, dentry);
+			}
+		}
+
+		buffer += directory_entry_length;
+	}
+
+	kfree(nbuffer);
+	leavef();
+	return ERR_PTR(-ENOENT);
+}
+
+static int smashfs_readpage (struct file *file, struct page *page)
+{
+	int rc;
+	int bytes_filled;
+	int max_block;
+	void *pgdata;
+	char *buffer;
+	long long size;
+	struct node *node;
+	struct inode *inode;
+	struct super_block *sb;
+
+	enterf();
+
+	inode = page->mapping->host;
+	sb = inode->i_sb;
+
+	node = &(smashfs_i(inode)->node);
+
+	max_block = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+	bytes_filled = 0;
+	pgdata = kmap(page);
+
+	debugf("page index: %ld, node size: %lld, max block: %d\n", page->index, node->size, max_block);
+	if (page->index < max_block) {
+		if (node->type == smashfs_inode_type_symbolic_link) {
+			buffer = pgdata;
+			size = min_t(long long, node->size - (page->index * PAGE_CACHE_SIZE), PAGE_CACHE_SIZE);
+			rc = node_read(sb, node, node_read_symbolic_link, &buffer, page->index * PAGE_CACHE_SIZE, size);
+			if (rc != 0) {
+				errorf("node read failed\n");
+				leavef();
+				goto bail;
+			}
+			bytes_filled = size;
+		} else if (node->type == smashfs_inode_type_regular_file) {
+			buffer = pgdata;
+			size = min_t(long long, node->size - (page->index * PAGE_CACHE_SIZE), PAGE_CACHE_SIZE);
+			rc = node_read(sb, node, node_read_regular_file, &buffer, page->index * PAGE_CACHE_SIZE, size);
+			if (rc != 0) {
+				errorf("node read failed\n");
+				leavef();
+				goto bail;
+			}
+			bytes_filled = size;
+		} else {
+			errorf("unknown node type: %lld\n", node->type);
+			goto bail;
+		}
+	}
+
+	memset(pgdata + bytes_filled, 0, PAGE_CACHE_SIZE - bytes_filled);
+	flush_dcache_page(page);
+	kunmap(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	leavef();
+	return 0;
+bail:
+	kunmap(page);
+	ClearPageUptodate(page);
+	SetPageError(page);
+	unlock_page(page);
+	leavef();
+	return 0;
+}
+
+static struct inode * smashfs_alloc_inode (struct super_block *sb)
+{
+	struct node_info *node;
+	node = kmem_cache_alloc(smashfs_inode_cachep, GFP_KERNEL);
+	return node ? &node->inode : NULL;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+
+static void smashfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(smashfs_inode_cachep, smashfs_i(inode));
+}
+
+#else
+
+static void smashfs_i_callback (struct rcu_head *head)
+{
+	struct inode *inode;
+	inode = container_of(head, struct inode, i_rcu);
+	INIT_LIST_HEAD(&inode->i_dentry);
+	kmem_cache_free(smashfs_inode_cachep, smashfs_i(inode));
+}
+
+static void smashfs_destroy_inode(struct inode *inode)
+{
+	call_rcu(&inode->i_rcu, smashfs_i_callback);
+}
+
+#endif
+
+static int smashfs_statfs (struct dentry *dentry, struct kstatfs *buf)
+{
+	u64 id;
+	struct smashfs_super_info *sbi;
+
+	enterf();
+
+	sbi = dentry->d_sb->s_fs_info;
+	id = huge_encode_dev(dentry->d_sb->s_bdev->bd_dev);
+	buf->f_type = SMASHFS_MAGIC;
+	buf->f_bsize = sbi->super->block_size;
+	buf->f_blocks = sbi->super->blocks;
+	buf->f_bfree = 0;
+	buf->f_bavail = 0;
+	buf->f_files = sbi->super->inodes;
+	buf->f_ffree = 0;
+	buf->f_namelen = SMASHFS_NAME_LEN;
+	buf->f_fsid.val[0] = (u32) id;
+	buf->f_fsid.val[1] = (u32) (id >> 32);
+
+	leavef();
+	return 0;
+}
+
+static int smashfs_remount (struct super_block *sb, int *flags, char *data)
+{
+	enterf();
+
+	*flags |= MS_RDONLY;
+
+	leavef();
+	return 0;
+}
+
+
+static void smashfs_put_super (struct super_block *sb)
+{
+	struct smashfs_super_info *sbi;
+
+	enterf();
+
+	if (sb->s_fs_info == NULL) {
+		debugf("sb->s_fs_info is null\n");
+		leavef();
+		return;
+	}
+	sbi = sb->s_fs_info;
+	sb->s_fs_info = NULL;
+	kfree(sbi->inodes_table);
+	kfree(sbi->blocks_table);
+	compressor_destroy(sbi->compressor);
+	kfree(sbi->super);
+	kfree(sbi);
+
+	leavef();
+}
+
+static const struct file_operations smashfs_directory_operations = {
+	.llseek  = default_llseek,
+	.read    = generic_read_dir,
+	.readdir = smashfs_readdir,
+};
+
+static const struct inode_operations smashfs_dir_inode_operations = {
+	.lookup = smashfs_lookup,
+};
+
+static const struct address_space_operations smashfs_aops = {
+	.readpage = smashfs_readpage
+};
+
+static const struct super_operations smashfs_super_ops = {
+	.alloc_inode   = smashfs_alloc_inode,
+	.destroy_inode = smashfs_destroy_inode,
+	.statfs        = smashfs_statfs,
+	.put_super     = smashfs_put_super,
+	.remount_fs    = smashfs_remount
+};
+
+static void init_once (void *foo)
+{
+	struct node_info *node;
+	node = foo;
+	inode_init_once(&node->inode);
+}
+
+static int init_inodecache (void)
+{
+	smashfs_inode_cachep = kmem_cache_create("smashfs_inode_cache", sizeof(struct node_info), 0, SLAB_HWCACHE_ALIGN | SLAB_RECLAIM_ACCOUNT, init_once);
+	return smashfs_inode_cachep ? 0 : -ENOMEM;
+}
+
+
+static void destroy_inodecache (void)
+{
+	if (smashfs_inode_cachep != NULL) {
+		kmem_cache_destroy(smashfs_inode_cachep);
+	}
+}
+
+static int smashfs_fill_super (struct super_block *sb, void *data, int silent)
+{
+	int rc;
+	char b[BDEVNAME_SIZE];
+	void *cbuffer;
+	struct inode *root;
+	struct smashfs_super_info *sbi;
+	struct smashfs_super_block *sbl;
+
+	enterf();
+
+	sbi = NULL;
+	sbl = NULL;
+	cbuffer = NULL;
+	sbi = kmalloc(sizeof(struct smashfs_super_info), GFP_KERNEL);
+	if (sbi == NULL) {
+		errorf("kalloc failed for super info\n");
+		goto bail;
+	}
+
+	sb->s_fs_info = sbi;
+	sbi->compressor = NULL;
+	sbi->blocks_table = NULL;
+	sbi->inodes_table = NULL;
+
+	(void) b;
+	debugf("devname: %s\n", bdevname(sb->s_bdev, b));
+
+	sbi->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	sbi->devblksize_log2 = ffz(~sbi->devblksize);
+
+	debugf("dev block size: %d, log2: %d", sbi->devblksize, sbi->devblksize_log2);
+
+	sbl = kmalloc(sizeof(struct smashfs_super_block), GFP_KERNEL);
+	if (sbl == NULL) {
+		errorf("kalloc failed for super block\n");
+		goto bail;
+	}
+	sbi->super = sbl;
+
+	rc = smashfs_read(sb, sbl, SMASHFS_START, sizeof(struct smashfs_super_block));
+	if (rc != sizeof(struct smashfs_super_block)) {
+		errorf("could not read super block\n");
+		goto bail;
+	}
+
+	if (sbl->magic != SMASHFS_MAGIC) {
+		errorf("magic mismatch\n");
+		goto bail;
+	}
+
+	debugf("super block:\n");
+	debugf("  magic         : 0x%08x, %u\n", sbl->magic, sbl->magic);
+	debugf("  version       : 0x%08x, %u\n", sbl->version, sbl->version);
+	debugf("  ctime         : 0x%08x, %u\n", sbl->ctime, sbl->ctime);
+	debugf("  block_size    : 0x%08x, %u\n", sbl->block_size, sbl->block_size);
+	debugf("  block_log2    : 0x%08x, %u\n", sbl->block_log2, sbl->block_log2);
+	debugf("  inodes        : 0x%08x, %u\n", sbl->inodes, sbl->inodes);
+	debugf("  blocks        : 0x%08x, %u\n", sbl->blocks, sbl->blocks);
+	debugf("  root          : 0x%08x, %u\n", sbl->root, sbl->root);
+	debugf("  inodes_offset : 0x%08x, %u\n", sbl->inodes_offset, sbl->inodes_offset);
+	debugf("  inodes_size   : 0x%08x, %u\n", sbl->inodes_size, sbl->inodes_size);
+	debugf("  inodes_csize  : 0x%08x, %u\n", sbl->inodes_csize, sbl->inodes_csize);
+	debugf("  blocks_offset : 0x%08x, %u\n", sbl->blocks_offset, sbl->blocks_offset);
+	debugf("  blocks_size   : 0x%08x, %u\n", sbl->blocks_size, sbl->blocks_size);
+	debugf("  entries_offset: 0x%08x, %u\n", sbl->entries_offset, sbl->entries_offset);
+	debugf("  entries_size  : 0x%08x, %u\n", sbl->entries_size, sbl->entries_size);
+	debugf("  bits:\n");
+	debugf("    min:\n");
+	debugf("      inode:\n");
+	debugf("        ctime : 0x%08x, %u\n", sbl->min.inode.ctime, sbl->min.inode.ctime);
+	debugf("        mtime : 0x%08x, %u\n", sbl->min.inode.mtime, sbl->min.inode.mtime);
+	debugf("      block:\n");
+	debugf("        compressed_size : 0x%08x, %u\n", sbl->min.block.compressed_size, sbl->min.block.compressed_size);
+	debugf("    inode:\n");
+	debugf("      type      : %u\n", sbl->bits.inode.type);
+	debugf("      owner_mode: %u\n", sbl->bits.inode.owner_mode);
+	debugf("      group_mode: %u\n", sbl->bits.inode.group_mode);
+	debugf("      other_mode: %u\n", sbl->bits.inode.other_mode);
+	debugf("      uid       : %u\n", sbl->bits.inode.uid);
+	debugf("      gid       : %u\n", sbl->bits.inode.gid);
+	debugf("      ctime     : %u\n", sbl->bits.inode.ctime);
+	debugf("      mtime     : %u\n", sbl->bits.inode.mtime);
+	debugf("      size      : %u\n", sbl->bits.inode.size);
+	debugf("      block     : %u\n", sbl->bits.inode.block);
+	debugf("      index     : %u\n", sbl->bits.inode.index);
+	debugf("      regular_file:\n");
+	debugf("      directory:\n");
+	debugf("        parent   : %u\n", sbl->bits.inode.directory.parent);
+	debugf("        nentries : %u\n", sbl->bits.inode.directory.nentries);
+	debugf("        entries:\n");
+	debugf("          number : %u\n", sbl->bits.inode.directory.entries.number);
+	debugf("          length : %u\n", sbl->bits.inode.directory.entries.length);
+	debugf("      symbolic_link:\n");
+	debugf("    block:\n");
+	debugf("      offset         : %u\n", sbl->bits.block.offset);
+	debugf("      compressed_size: %u\n", sbl->bits.block.compressed_size);
+	debugf("      size           : %u\n", sbl->bits.block.size);
+
+	sbi->compressor = compressor_create_type(sbl->compression_type);
+	if (sbi->compressor == NULL) {
+		errorf("compressor create failed\n");
+		goto bail;
+	}
+
+	sbi->max_inode_size  = 0;
+	sbi->max_inode_size += sbl->bits.inode.type;
+	sbi->max_inode_size += sbl->bits.inode.owner_mode;
+	sbi->max_inode_size += sbl->bits.inode.group_mode;
+	sbi->max_inode_size += sbl->bits.inode.other_mode;
+	sbi->max_inode_size += sbl->bits.inode.uid;;
+	sbi->max_inode_size += sbl->bits.inode.gid;
+	sbi->max_inode_size += sbl->bits.inode.ctime;
+	sbi->max_inode_size += sbl->bits.inode.mtime;
+	sbi->max_inode_size += sbl->bits.inode.size;
+	sbi->max_inode_size += sbl->bits.inode.block;
+	sbi->max_inode_size += sbl->bits.inode.index;
+
+	sbi->inodes_table = kmalloc(sbl->inodes_size, GFP_KERNEL);
+	if (sbi->inodes_table == NULL) {
+		errorf("kmalloc failed for inodes table\n");
+		goto bail;
+	}
+
+	sbi->max_block_size  = 0;
+	sbi->max_block_size += sbl->bits.block.offset;
+	sbi->max_block_size += sbl->bits.block.compressed_size;
+
+	sbi->blocks_table = kmalloc(sbl->blocks_size, GFP_KERNEL);
+
+	if (sbi->blocks_table == NULL) {
+		errorf("kmalloc failed for blocks table\n");
+		goto bail;
+	}
+
+	cbuffer = kmalloc(sbl->inodes_csize, GFP_KERNEL);
+	if (cbuffer == NULL) {
+		errorf("kmalloc failed\n");
+		goto bail;
+	}
+	rc = smashfs_read(sb, cbuffer, sbl->inodes_offset, sbl->inodes_csize);
+	if (rc != sbl->inodes_csize) {
+		errorf("read failed for inodes table\n");
+		goto bail;
+	}
+	rc = compressor_uncompress(sbi->compressor, cbuffer, sbl->inodes_csize, sbi->inodes_table, sbl->inodes_size);
+	if (rc != sbl->inodes_size) {
+		errorf("uncompress failed\n");
+		goto bail;
+	}
+	kfree(cbuffer);
+	cbuffer = NULL;
+
+	rc = smashfs_read(sb, sbi->blocks_table, sbl->blocks_offset, sbl->blocks_size);
+	if (rc != sbl->blocks_size) {
+		errorf("read failed for blocks table\n");
+		goto bail;
+	}
+
+	sb->s_magic = sbl->magic;
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+	sb->s_flags |= MS_RDONLY;
+	sb->s_op = &smashfs_super_ops;
+
+	root = smashfs_get_inode(sb, sbl->root);
+	if (IS_ERR(root)) {
+		errorf("can not get root inode\n");
+		goto bail;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+	sb->s_root = d_alloc_root(root);
+#else
+	sb->s_root = d_make_root(root);
+#endif
+	if (!sb->s_root) {
+		errorf("d_alloc_root failed\n");
+		iput(root);
+		goto bail;
+	}
+
+	if (cbuffer != NULL) {
+		kfree(cbuffer);
+	}
+	leavef();
+	return 0;
+bail:
+	if (sbi != NULL) {
+		if (sbi->blocks_table != NULL) {
+			kfree(sbi->blocks_table);
+		}
+		if (sbi->inodes_table != NULL) {
+			kfree(sbi->inodes_table);
+		}
+		if (sbi->compressor != NULL) {
+			compressor_destroy(sbi->compressor);
+		}
+		kfree(sbi);
+	}
+	if (cbuffer != NULL) {
+		kfree(cbuffer);
+	}
+	if (sbl != NULL) {
+		kfree(sbl);
+	}
+	sb->s_fs_info = NULL;
+	leavef();
+	return -EINVAL;
+}
+
+static struct dentry * smashfs_mount(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)
+{
+	return mount_bdev(fs_type, flags, dev_name, data, smashfs_fill_super);
+}
+
+static struct file_system_type smashfs_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "smashfs",
+	.mount		= smashfs_mount,
+	.kill_sb	= kill_block_super,
+	.fs_flags	= FS_REQUIRES_DEV,
+};
+
+static int __init init_smashfs_fs (void)
+{
+	int rc;
+	block_caches = kmalloc(sizeof(struct block_cache) * block_caches_max, GFP_KERNEL);
+	if (block_caches == NULL) {
+		errorf("kmalloc failed\n");
+		goto bail;
+	}
+	rc = init_inodecache();
+	if (rc != 0) {
+		errorf("inode cache init failed\n");
+		goto bail;
+	}
+	rc = register_filesystem(&smashfs_fs_type);
+	printk(KERN_INFO "smashfs: (c) 2013 Alper Akcan <alper.akcan@gmail.com>\n");
+	printk(KERN_INFO "smashfs: (c) 2013 Alper Akcan <alper.akcan@gmail.com> %d\n", block_caches_max);
+	return rc;
+bail:
+	destroy_inodecache();
+	if (block_caches != NULL) {
+		kfree(block_caches);
+	}
+	return rc;
+}
+
+static void __exit exit_smashfs_fs (void)
+{
+	unregister_filesystem(&smashfs_fs_type);
+	destroy_inodecache();
+	if (block_caches != NULL) {
+		kfree(block_caches);
+	}
+}
+
+module_init(init_smashfs_fs)
+module_exit(exit_smashfs_fs)
+MODULE_LICENSE("GPL");
Index: fs/smashfs/Kconfig
===================================================================
--- fs/smashfs/Kconfig	(revision 0)
+++ fs/smashfs/Kconfig	(revision 0)
@@ -0,0 +1,28 @@
+config SMASHFS
+	tristate "SmashFS - Smashed file system support"
+	depends on BLOCK
+	select ZLIB_INFLATE
+
+config SMASHFS_ENABLE_XZ
+	bool "Include support for XZ compressed file systems"
+	depends on SMASHFS
+	default n
+	select XZ_DEC
+
+config SMASHFS_ENABLE_LZO
+	bool "Include support for LZO compressed file systems"
+	depends on SMASHFS
+	default n
+	select LZO_DECOMPRESS
+
+config SMASHFS_ENABLE_LZMA
+	bool "Include support for LZMA compressed file systems"
+	depends on SMASHFS
+	default n
+	select LZMA_DECOMPRESS
+
+config SMASHFS_ENABLE_GZIP
+	bool "Include support for GZIP compressed file systems"
+	depends on SMASHFS
+	default n
+	select DECOMPRESS_GZIP
Index: fs/smashfs/compressor-xz.h
===================================================================
--- fs/smashfs/compressor-xz.h	(revision 0)
+++ fs/smashfs/compressor-xz.h	(revision 0)
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+int xz_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
+int xz_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
Index: fs/smashfs/compressor.h
===================================================================
--- fs/smashfs/compressor.h	(revision 0)
+++ fs/smashfs/compressor.h	(revision 0)
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+struct compressor;
+
+struct compressor * compressor_create_name (const char *name);
+struct compressor * compressor_create_type (enum smashfs_compression_type type);
+int compressor_destroy (struct compressor *compressor);
+enum smashfs_compression_type compressor_type (struct compressor *compressor);
+int compressor_compress (struct compressor *compressor, void *src, unsigned int ssize, void *dst, unsigned int dsize);
+int compressor_uncompress (struct compressor *compressor, void *src, unsigned int ssize, void *dst, unsigned int dsize);
Index: fs/smashfs/compressor-lzma.h
===================================================================
--- fs/smashfs/compressor-lzma.h	(revision 0)
+++ fs/smashfs/compressor-lzma.h	(revision 0)
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+int lzma_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
+int lzma_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
Index: fs/smashfs/super.h
===================================================================
--- fs/smashfs/super.h	(revision 0)
+++ fs/smashfs/super.h	(revision 0)
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+struct smashfs_super_info {
+	int devblksize;
+	int devblksize_log2;
+	long long max_inode_size;
+	long long max_block_size;
+	struct smashfs_super_block *super;
+	unsigned char *inodes_table;
+	unsigned char *blocks_table;
+	struct compressor *compressor;
+};
Index: fs/smashfs/compressor-lzo.h
===================================================================
--- fs/smashfs/compressor-lzo.h	(revision 0)
+++ fs/smashfs/compressor-lzo.h	(revision 0)
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+int lzo_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
+int lzo_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
Index: fs/smashfs/compressor-gzip.c
===================================================================
--- fs/smashfs/compressor-gzip.c	(revision 0)
+++ fs/smashfs/compressor-gzip.c	(revision 0)
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <linux/zlib.h>
+
+int gzip_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	(void) src;
+	(void) ssize;
+	(void) dst;
+	(void) dsize;
+	return -1;
+}
+
+int gzip_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	int rc;
+	z_stream stream;
+
+	stream.workspace = vmalloc(zlib_inflate_workspacesize());
+	if (stream.workspace == NULL) {
+		return -1;
+	}
+
+	stream.next_in = NULL;
+	stream.avail_in = 0;
+	zlib_inflateInit2(&stream, -MAX_WBITS);
+
+	stream.next_in = src;
+	stream.avail_in = ssize;
+
+	stream.next_out = dst;
+	stream.avail_out = dsize;
+
+	rc = zlib_inflateReset(&stream);
+	if (rc != Z_OK) {
+		zlib_inflateEnd(&stream);
+		zlib_inflateInit2(&stream, -MAX_WBITS);
+	}
+
+	rc = zlib_inflate(&stream, Z_FINISH);
+	if (rc != Z_STREAM_END) {
+		zlib_inflateEnd(&stream);
+		vfree(stream.workspace);
+		return -1;
+	}
+
+	zlib_inflateEnd(&stream);
+	vfree(stream.workspace);
+	return stream.total_out;
+}
Index: fs/smashfs/bitbuffer.c
===================================================================
--- fs/smashfs/bitbuffer.c	(revision 0)
+++ fs/smashfs/bitbuffer.c	(revision 0)
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2011-2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation are those
+ * of the authors and should not be interpreted as representing official policies,
+ * either expressed or implied, of the FreeBSD Project.
+ */
+
+#include <linux/module.h>
+#include "bitbuffer.h"
+
+#define MAX(a, b) (((a) > (b)) ? (a) : (b))
+
+int bitbuffer_init_from_buffer (struct bitbuffer *bitbuffer, unsigned char *buffer, int size)
+{
+	struct bitbuffer *b;
+	b = bitbuffer;
+	b->buffer = buffer;
+	b->size = size;
+	b->bsize = size * 8;
+	b->end = buffer + b->size;
+	b->index = 0;
+	b->external = 1;
+	return 0;
+}
+
+void bitbuffer_uninit (struct bitbuffer *bitbuffer)
+{
+	bitbuffer_init_from_buffer(bitbuffer, NULL, 0);
+}
+
+void * bitbuffer_buffer (struct bitbuffer *bitbuffer)
+{
+	return bitbuffer->buffer;
+}
+
+unsigned int bitbuffer_getlength (struct bitbuffer *bitbuffer)
+{
+	return (bitbuffer_getbitlength(bitbuffer) + 7 ) / 8;
+}
+
+unsigned int bitbuffer_getbitlength (struct bitbuffer *bitbuffer)
+{
+	return MAX(bitbuffer->bsize - bitbuffer->index, 0);
+}
+
+unsigned int bitbuffer_getpos (struct bitbuffer *bitbuffer)
+{
+	return bitbuffer->index;
+}
+
+unsigned int bitbuffer_setpos (struct bitbuffer *bitbuffer, unsigned int pos)
+{
+	bitbuffer->index = pos;
+	return 0;
+}
+
+void bitbuffer_putbit (struct bitbuffer *bitbuffer, unsigned int value)
+{
+	int bit;
+	int byte;
+	bit = bitbuffer->index % 8;
+	byte = bitbuffer->index / 8;
+	bitbuffer->buffer[byte] |= ((value & 0x01) << (7 - bit));
+	bitbuffer->index++;
+}
+
+void bitbuffer_putbits (struct bitbuffer *bitbuffer, int n, unsigned int value)
+{
+	unsigned int v = value;
+	while (n) {
+		bitbuffer_putbit(bitbuffer, (v >> (n - 1)) & 0x01);
+		n -= 1;
+	}
+}
+
+unsigned int bitbuffer_getbit (struct bitbuffer *bitbuffer)
+{
+	int bit;
+	int byte;
+	bit = bitbuffer->index % 8;
+	byte = bitbuffer->index / 8;
+	bitbuffer->index++;
+	return (bitbuffer->buffer[byte] >> (7 - bit)) & 0x01;
+}
+
+unsigned int bitbuffer_getbits (struct bitbuffer *bitbuffer, int n)
+{
+	unsigned int tmp = 0;
+	while (n) {
+		if (((bitbuffer->index % 8) == 0) && (n >= 8)) {
+			while (n >= 8) {
+				tmp = (tmp << 0x08) | bitbuffer->buffer[bitbuffer->index / 8];
+				bitbuffer->index += 8;
+				n -= 8;
+			}
+		} else {
+			tmp = (tmp << 1) | bitbuffer_getbit(bitbuffer);
+			n -= 1;
+		}
+	}
+	return tmp;
+}
+
+unsigned int bitbuffer_getbuffer (struct bitbuffer *bitbuffer, char *buffer, int n)
+{
+	int i;
+	if ((bitbuffer->index % 8) != 0) {
+		for (i = 0; i < n; i++) {
+			buffer[i] = bitbuffer_getbits(bitbuffer, 8);
+		}
+	} else {
+		memcpy(buffer, &bitbuffer->buffer[bitbuffer->index / 8], n);
+		bitbuffer->index += n * 8;
+	}
+	return 0;
+}
+
+unsigned int bitbuffer_skipbits (struct bitbuffer *bitbuffer, int n)
+{
+	bitbuffer->index += n;
+	return 0;
+}
+
+unsigned int bitbuffer_showbits (struct bitbuffer *bitbuffer, int n)
+{
+	int index;
+	unsigned int tmp = 0;
+	index = bitbuffer->index;
+	tmp = bitbuffer_getbits(bitbuffer, n);
+	bitbuffer->index = index;
+	return tmp;
+}
+
+unsigned int bitbuffer_copybits (struct bitbuffer *pbitbuffer, struct bitbuffer *gbitbuffer, int n)
+{
+	unsigned int el = bitbuffer_getbits(gbitbuffer, n);
+	bitbuffer_putbits(pbitbuffer, n, el);
+	return el;
+}
Index: fs/smashfs/compressor-gzip.h
===================================================================
--- fs/smashfs/compressor-gzip.h	(revision 0)
+++ fs/smashfs/compressor-gzip.h	(revision 0)
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+int gzip_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
+int gzip_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize);
Index: fs/smashfs/smashfs.h
===================================================================
--- fs/smashfs/smashfs.h	(revision 0)
+++ fs/smashfs/smashfs.h	(revision 0)
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation are those
+ * of the authors and should not be interpreted as representing official policies,
+ * either expressed or implied, of the FreeBSD Project.
+ */
+
+#define SMASHFS_MKTAG(a, b, c, d)		(((a) << 0x18) | ((b) << 0x10) | ((c) << 0x08) | ((d) << 0x00))
+#define SMASHFS_MAGIC				SMASHFS_MKTAG('S', 'M', 'S', 'H')
+#define SMASHFS_VERSION_0			SMASHFS_MKTAG('V', '0', '0', '0')
+
+#define SMASHFS_START				0
+#define SMASHFS_NAME_LEN			256
+
+enum smashfs_compression_type {
+	smashfs_compression_type_none		= 0x00,
+	smashfs_compression_type_gzip		= 0x01,
+	smashfs_compression_type_lzma		= 0x02,
+	smashfs_compression_type_lzo		= 0x03,
+	smashfs_compression_type_xz		= 0x04,
+};
+
+enum smashfs_inode_type {
+	smashfs_inode_type_regular_file		= 0x01,
+	smashfs_inode_type_directory		= 0x02,
+	smashfs_inode_type_symbolic_link	= 0x03,
+	smashfs_inode_type_character_device	= 0x04,
+	smashfs_inode_type_block_device		= 0x05,
+	smashfs_inode_type_fifo			= 0x06,
+	smashfs_inode_type_socket		= 0x07,
+};
+
+enum smashfs_inode_mode {
+	smashfs_inode_mode_read			= 0x01,
+	smashfs_inode_mode_write		= 0x02,
+	smashfs_inode_mode_execute		= 0x04,
+};
+
+struct smashfs_super_block {
+	uint32_t magic;
+	uint32_t version;
+	uint32_t ctime;
+	uint32_t inodes;
+	uint32_t blocks;
+	uint32_t block_size;
+	uint32_t block_log2;
+	uint32_t root;
+	uint32_t inodes_offset;
+	uint32_t inodes_size;
+	uint32_t inodes_csize;
+	uint32_t blocks_offset;
+	uint32_t blocks_size;
+	uint32_t entries_offset;
+	uint32_t entries_size;
+	uint32_t compression_type;
+	struct {
+		struct {
+			uint32_t type;
+			uint32_t owner_mode;
+			uint32_t group_mode;
+			uint32_t other_mode;
+			uint32_t uid;
+			uint32_t gid;
+			uint32_t ctime;
+			uint32_t mtime;
+			uint32_t size;
+			uint32_t block;
+			uint32_t index;
+			struct {
+				char content[0];
+			} regular_file;
+			struct {
+				uint32_t parent;
+				uint32_t nentries;
+				struct {
+					uint32_t number;
+					uint32_t length;
+					uint32_t type;
+					char path[0];
+				} entries;
+			} directory;
+			struct {
+				char path[0];
+			} symbolic_link;
+		} inode;
+		struct {
+			uint32_t offset;
+			uint32_t compressed_size;
+			uint32_t size;
+		} block;
+	} bits;
+	struct {
+		struct {
+			uint32_t ctime;
+			uint32_t mtime;
+		} inode;
+		struct {
+			uint32_t compressed_size;
+		} block;
+	} min;
+} __attribute__((packed));
Index: fs/smashfs/bitbuffer.h
===================================================================
--- fs/smashfs/bitbuffer.h	(revision 0)
+++ fs/smashfs/bitbuffer.h	(revision 0)
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2011-2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation are those
+ * of the authors and should not be interpreted as representing official policies,
+ * either expressed or implied, of the FreeBSD Project.
+ */
+
+#define BITBUFFER_INITIALIZER { \
+	.buffer = NULL, \
+	.end = NULL, \
+	.size = 0, \
+	.bsize = 0, \
+	.index = 0, \
+	.external = 0, \
+}
+
+struct bitbuffer {
+	unsigned char *buffer;
+	unsigned char *end;
+	int size;
+	int bsize;
+	int index;
+	int external;
+};
+
+int bitbuffer_init (struct bitbuffer *bitbuffer, int size);
+int bitbuffer_init_from_buffer (struct bitbuffer *bitbuffer, unsigned char *buffer, int size);
+void bitbuffer_uninit (struct bitbuffer *bitbuffer);
+void * bitbuffer_buffer (struct bitbuffer *bitbuffer);
+unsigned int bitbuffer_getlength (struct bitbuffer *bitbuffer);
+unsigned int bitbuffer_getbitlength (struct bitbuffer *bitbuffer);
+unsigned int bitbuffer_getpos (struct bitbuffer *bitbuffer);
+unsigned int bitbuffer_setpos (struct bitbuffer *bitbuffer, unsigned int pos);
+void bitbuffer_putbit (struct bitbuffer *bitbuffer, unsigned int value);
+void bitbuffer_putbits (struct bitbuffer *bitbuffer, int n, unsigned int value);
+unsigned int bitbuffer_getbit (struct bitbuffer *bitbuffer);
+unsigned int bitbuffer_getbits (struct bitbuffer *bitbuffer, int n);
+unsigned int bitbuffer_getbuffer (struct bitbuffer *bitbuffer, char *buffer, int n);
+unsigned int bitbuffer_skipbits (struct bitbuffer *bitbuffer, int n);
+unsigned int bitbuffer_showbits (struct bitbuffer *bitbuffer, int n);
+unsigned int bitbuffer_copybits (struct bitbuffer *pbitbuffer, struct bitbuffer *gbitbuffer, int n);
Index: fs/smashfs/compressor-none.c
===================================================================
--- fs/smashfs/compressor-none.c	(revision 0)
+++ fs/smashfs/compressor-none.c	(revision 0)
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+
+int none_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	if (dsize < ssize) {
+		return -1;
+	}
+	memcpy(dst, src, ssize);
+	return ssize;
+}
+
+int none_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	if (dsize < ssize) {
+		return -1;
+	}
+	memcpy(dst, src, ssize);
+	return ssize;
+}
Index: fs/smashfs/compressor-xz.c
===================================================================
--- fs/smashfs/compressor-xz.c	(revision 0)
+++ fs/smashfs/compressor-xz.c	(revision 0)
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/xz.h>
+
+int xz_compress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	(void) src;
+	(void) ssize;
+	(void) dst;
+	(void) dsize;
+	return -1;
+}
+
+int xz_uncompress (void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	enum xz_ret ret;
+	struct xz_buf b;
+	struct xz_dec *s;
+	//xz_crc32_init();
+	s = xz_dec_init(XZ_SINGLE, 0);
+	if (s == NULL) {
+		return -1;
+	}
+	b.in = src;
+	b.in_pos = 0;
+	b.in_size = ssize;
+	b.out = dst;
+	b.out_pos = 0;
+	b.out_size = dsize;
+	ret = xz_dec_run(s, &b);
+	xz_dec_end(s);
+	return (ret == XZ_STREAM_END) ? b.out_pos : -1;
+}
Index: fs/smashfs/Makefile
===================================================================
--- fs/smashfs/Makefile	(revision 0)
+++ fs/smashfs/Makefile	(revision 0)
@@ -0,0 +1,42 @@
+#
+# Makefile for the linux smashfs routines.
+#
+
+SMASHFS_ENABLE_GZIP ?= y
+SMASHFS_ENABLE_LZMA ?= y
+SMASHFS_ENABLE_LZO  ?= y
+SMASHFS_ENABLE_XZ   ?= y
+
+cflags-y                       =
+cflags-${SMASHFS_ENABLE_GZIP} += -DSMASHFS_ENABLE_GZIP=1
+cflags-${SMASHFS_ENABLE_LZMA} += -DSMASHFS_ENABLE_LZMA=1
+cflags-${SMASHFS_ENABLE_LZO}  += -DSMASHFS_ENABLE_LZO=1
+cflags-${SMASHFS_ENABLE_XZ}   += -DSMASHFS_ENABLE_XZ=1
+
+EXTRA_CFLAGS  = ${cflags-y}
+
+obj-$(CONFIG_SMASHFS) += \
+	smashfs.o
+
+smashfs-y += \
+	bitbuffer.o \
+	compressor.o \
+	compressor-none.o \
+	super.o
+
+ifeq (${SMASHFS_ENABLE_GZIP}, y)
+smashfs-y += \
+	compressor-gzip.o
+endif
+ifeq (${SMASHFS_ENABLE_LZMA}, y)
+smashfs-y += \
+	compressor-lzma.o
+endif
+ifeq (${SMASHFS_ENABLE_LZO}, y)
+smashfs-y += \
+	compressor-lzo.o
+endif
+ifeq (${SMASHFS_ENABLE_XZ}, y)
+smashfs-y += \
+	compressor-xz.o
+endif
Index: fs/smashfs/compressor.c
===================================================================
--- fs/smashfs/compressor.c	(revision 0)
+++ fs/smashfs/compressor.c	(revision 0)
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2013, Alper Akcan <alper.akcan@gmail.com>.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+
+#include "smashfs.h"
+
+#include "compressor.h"
+#include "compressor-none.h"
+#if defined(SMASHFS_ENABLE_GZIP) && (SMASHFS_ENABLE_GZIP == 1)
+#include "compressor-gzip.h"
+#endif
+#if defined(SMASHFS_ENABLE_LZMA) && (SMASHFS_ENABLE_LZMA == 1)
+#endif
+#include "compressor-lzma.h"
+#if defined(SMASHFS_ENABLE_LZO) && (SMASHFS_ENABLE_LZO == 1)
+#include "compressor-lzo.h"
+#endif
+#if defined(SMASHFS_ENABLE_XZ) && (SMASHFS_ENABLE_XZ == 1)
+#include "compressor-xz.h"
+#endif
+
+struct compressor {
+	char *name;
+	enum smashfs_compression_type type;
+	int (*compress) (void *src, unsigned int ssize, void *dst, unsigned int dsize);
+	int (*uncompress) (void *src, unsigned int ssize, void *dst, unsigned int dsize);
+};
+
+struct compressor *compressors[] = {
+	& (struct compressor) { "none", smashfs_compression_type_none, none_compress, none_uncompress },
+#if defined(SMASHFS_ENABLE_GZIP) && (SMASHFS_ENABLE_GZIP == 1)
+	& (struct compressor) { "gzip", smashfs_compression_type_gzip, gzip_compress, gzip_uncompress },
+#endif
+#if defined(SMASHFS_ENABLE_LZMA) && (SMASHFS_ENABLE_LZMA == 1)
+	& (struct compressor) { "lzma", smashfs_compression_type_lzma, lzma_compress, lzma_uncompress },
+#endif
+#if defined(SMASHFS_ENABLE_LZO) && (SMASHFS_ENABLE_LZO == 1)
+	& (struct compressor) { "lzo" , smashfs_compression_type_lzo , lzo_compress , lzo_uncompress  },
+#endif
+#if defined(SMASHFS_ENABLE_XZ) && (SMASHFS_ENABLE_XZ == 1)
+	& (struct compressor) { "xz"  , smashfs_compression_type_xz  , xz_compress  , xz_uncompress   },
+#endif
+	NULL
+};
+
+struct compressor * compressor_create_name (const char *name)
+{
+	struct compressor **c;
+	for (c = compressors; *c; c++) {
+		if (strcmp((*c)->name, name) == 0) {
+			return *c;
+		}
+	}
+	return NULL;
+}
+
+struct compressor * compressor_create_type (enum smashfs_compression_type type)
+{
+	struct compressor **c;
+	for (c = compressors; *c; c++) {
+		if ((*c)->type == type) {
+			return *c;
+		}
+	}
+	return NULL;
+}
+
+int compressor_destroy (struct compressor *compressor)
+{
+	(void) compressor;
+	return 0;
+}
+
+enum smashfs_compression_type compressor_type (struct compressor *compressor)
+{
+	return compressor->type;
+}
+
+int compressor_compress (struct compressor *compressor, void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	return compressor->compress(src, ssize, dst, dsize);
+}
+
+int compressor_uncompress (struct compressor *compressor, void *src, unsigned int ssize, void *dst, unsigned int dsize)
+{
+	return compressor->uncompress(src, ssize, dst, dsize);
+}
